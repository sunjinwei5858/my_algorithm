package com.sunjinwei._04_dp;

/**
 * 0-1背包问题 [物品可以装进背包也可以不装进背包]
 * 描述：给你一个可装载重量为w的背包和n个物品，每个物品有重量和价值两个属性
 * 第i个物品的重量为wt[i] 价值为val[i]，求最大价值
 * <p>
 * 力扣上的0-1背包问题：
 * <p>
 * 第416题：分割等和子集（中等）；
 * 第474题：一和零（中等）；
 * 第494题：目标和（中等）；
 * 第879题：盈利计划（困难）；
 * <p>
 * 力扣上的完全背包问题：
 * 第322题：零钱兑换（中等）；
 * 第518题：零钱兑换 II（中等）；
 * 第1449题：数位成本和为目标值的最大数字（困难）。
 * 这里要注意鉴别：力扣第377题，不是完全背包问题。
 */
public class _05_01_beibao {

    /**
     * 01背包：动态规划
     *
     * @param w   背包重量
     * @param n   物品数量
     * @param wt  物品对应的重量
     * @param val 物品对应的价值
     * @return
     */
    public int beibao(int w, int n, int[] wt, int[] val) {
        // 1状态定义：[i][j]代表在重量为j的背包中放入i个物品的最大价值
        // [0,0]在重量为0的背包中放入0个物品的最大价值就是0 所以此时[0,0]是没有意义的 那么二维数组的size就设置为n+1,w+1
        int[][] dp = new int[n + 1][w + 1];
        // 2base case
        // 不放入物品的时候 价值为0 不需要初始化了

        // 3外层循环 i代表物品数量n，物品重量在wt[]数组查询 物品价值在val[]
        // 内层循环 j代表背包重量w
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= w; j++) {
                // 不选择:
                // 物品重量大于背包重量 不能放物品 此时最大价值就是第i-1个物品的最大价值
                // 索引是从1开始 那么i的重量就是wt[i-1]
                if (j < wt[i - 1]) {
                    // 放i-1个物品，背包容量为j的最大价值
                    // 对于dp数组 i表示放入的物品数量 肯定是从1开始的
                    // 对于dp数组 j表示此时的背包的重量 相当于背包还有多少重量 即剩余重量
                    dp[i][j] = dp[i - 1][j];
                } else {
                    // 选择：
                    // 物品重量小于背包重量，可以放物品，价值需要和不放这个物品的价值比较
                    // 因为i的索引是从1开始的 所以对于i的重量和价值 应该是wt[i-1]和val[i-1]
                    // 选择不放入背包的价值
                    int s1 = dp[i - 1][j];
                    // 选择将物品放入背包，价值的计算：该物品的价值 + [i-1]对应的剩余背包重量的最大价值
                    // 当前背包的价值
                    int s2 = dp[i - 1][j - wt[i - 1]] + val[i - 1];
                    // 因为将该物品放入背包的价值，也就是s2不一定是最大价值，所以需要进行比较
                    dp[i][j] = Math.max(s1, s2);
                }
            }
        }
        return dp[n][w];
    }

}
