package com.sunjinwei._12_huiwen;

/**
 * 判断是否是回文数 力扣9
 * <p>
 * 给你一个整数x，如果x是一个回文整数，返回true；否则，返回false 。
 * <p>
 * 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如121是回文，而123不是。
 * <p>
 * 进阶：你能不将整数转为字符串来解决这个问题吗？
 * <p>
 * 思路：
 * 对数字进行反转一半 然后进行比较!!! 其实和回文链表的思路是一样的，对数字反转一半避免了溢出的问题!!!非常好的思路
 */
public class _04_huiwen_digit {

    /**
     * 不能将整数转为字符串来解决, 直接反转数字，但是直接反转数字 可能会导致溢出，所以这里可以考虑反转数字的一半
     * 如何对数字进行反转？
     * 利用取模和除法，对于数字x，x%10得到余数也就是x的个位数，x/10得到除去最后一位之前的数
     * 声明一个变量n用于存储反转后的数字，对于n，每次(n*10)+(x%10)；对于x，x=(x/10)
     * 什么反转到了一半？
     * 当反转后的数字大于原始数字时 break
     * 如何判断？
     *
     * @param x
     * @return
     */
    public boolean isPalindrome(int x) {
        // 如果是负数 那么不能回文数
        if (x < 0) {
            return false;
        } else if (x == 0) {
            return true;
        } else {
            // 1判断个位是不是0
            if (x % 10 == 0) {
                return false;
            } else {
                // 1将num % 10 可以得到最后一个数；然后继续 % 10 可以得到倒数第二个数 依次类推
                // 2然后 每一步 % 10 后，都将上一个数 * 10 ，两者相加 比如1221 第一步 1221%10=1 1221/10=122
                // 但是如何判断已经反转到一半了呢？
                // 因为整个过程不断的将原始数字除以10 然后给反转后的数字乘10 所以当原始数字小于或者等于反转后的数字时，就意味着已经处理了一半位数的数字了
                int reverseNumber = 0;
                while (x > reverseNumber) {
                    // 取余操作 1221%10=1
                    int y = x % 10;
                    // 将数字
                    reverseNumber = reverseNumber * 10 + y;
                    // 每次取完余数 都要进行除以10 获取除了最低位的数 比如1221/10=122
                    x = x / 10;
                }
                // 当数字长度为奇数时：12321 第一次1232 1 第二次123 12 第三次 12 123 此时break 那么将12和123/10进行比较即可!!!!!
                // 当数字长度为偶数时：1221 第一次122 1 第二次12 12 直接进行比较即可
                return x == reverseNumber || x == reverseNumber / 10;
            }
        }
    }
}
